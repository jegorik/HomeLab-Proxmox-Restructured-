---
# =============================================================================
# PostgreSQL Role - With Bind Mount Data Preservation
# =============================================================================
# Installs PostgreSQL 17 and configures database for NetBox
# Supports bind mount for data persistence across container recreations
#
# CRITICAL: This role detects existing data in bind mounts and preserves it
# instead of creating a fresh database cluster.
# =============================================================================

# --- User Setup (match bind mount UIDs) ---

- name: Create PostgreSQL group
  ansible.builtin.group:
    name: postgres
    gid: 109
    state: present
  tags: ["install", "user"]

- name: Create PostgreSQL user
  ansible.builtin.user:
    name: postgres
    uid: 105
    group: postgres
    home: /var/lib/postgresql
    shell: /bin/bash
    create_home: false
    state: present
  tags: ["install", "user"]

# --- Installation ---

- name: Install PostgreSQL server and dependencies
  ansible.builtin.apt:
    name:
      - postgresql-{{ postgres_version }}
      - postgresql-client-{{ postgres_version }}
      - python3-psycopg2
    state: present
    update_cache: true
    cache_valid_time: 3600
  tags: ["install"]

# --- Bind Mount Setup (CRITICAL for data persistence) ---

- name: Ensure PostgreSQL data directory has correct ownership
  ansible.builtin.file:
    path: /var/lib/postgresql
    state: directory
    owner: postgres
    group: postgres
    mode: "0755"
  tags: ["install", "permissions"]

# --- Cluster Initialization (preserves bind mount data) ---

- name: Check if PostgreSQL cluster is registered
  ansible.builtin.command:
    cmd: pg_lsclusters -h
  register: postgresql_clusters
  changed_when: false
  tags: ["install"]

- name: Check if main cluster exists
  ansible.builtin.set_fact:
    postgresql_cluster_exists: "{{ postgresql_clusters.stdout | regex_search('17\\s+main') is not none }}"
  tags: ["install"]

- name: Check if existing PostgreSQL data exists (bind mount preservation)
  ansible.builtin.stat:
    path: /var/lib/postgresql/{{ postgres_version }}/main/PG_VERSION
  register: postgresql_data_exists
  tags: ["install"]

- name: Display data detection results
  ansible.builtin.debug:
    msg:
      - "Cluster registered: {{ postgresql_cluster_exists }}"
      - "Existing data found: {{ postgresql_data_exists.stat.exists | default(false) }}"
  tags: ["install"]

# CRITICAL: Re-register existing cluster from bind mount data (DO NOT DELETE!)
# First ensure config directory exists (it won't after container recreation)
- name: Ensure PostgreSQL config directory exists
  ansible.builtin.file:
    path: /etc/postgresql/{{ postgres_version }}/main
    state: directory
    owner: postgres
    group: postgres
    mode: "0755"
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

# Create minimal postgresql.conf if not exists (required for pg_createcluster)
- name: Check if postgresql.conf exists in data dir
  ansible.builtin.stat:
    path: /var/lib/postgresql/{{ postgres_version }}/main/postgresql.conf
  register: postgresql_conf_in_data
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

# pg_createcluster needs postgresql.conf - create it from postmaster.opts or defaults
- name: Generate default postgresql.conf for existing data
  ansible.builtin.shell:
    cmd: |
      # Create config in /etc/postgresql location (Debian standard)
      cat > /etc/postgresql/{{ postgres_version }}/main/postgresql.conf << 'EOF'
      # Auto-generated config for existing data directory
      data_directory = '/var/lib/postgresql/{{ postgres_version }}/main'
      hba_file = '/etc/postgresql/{{ postgres_version }}/main/pg_hba.conf'
      ident_file = '/etc/postgresql/{{ postgres_version }}/main/pg_ident.conf'
      external_pid_file = '/var/run/postgresql/{{ postgres_version }}-main.pid'
      port = 5432
      max_connections = 100
      unix_socket_directories = '/var/run/postgresql'
      ssl = on
      ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'
      ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'
      shared_buffers = 128MB
      dynamic_shared_memory_type = posix
      max_wal_size = 1GB
      min_wal_size = 80MB
      log_line_prefix = '%m [%p] %q%u@%d '
      log_timezone = 'Etc/UTC'
      datestyle = 'iso, mdy'
      timezone = 'Etc/UTC'
      lc_messages = 'C.UTF-8'
      lc_monetary = 'C.UTF-8'
      lc_numeric = 'C.UTF-8'
      lc_time = 'C.UTF-8'
      default_text_search_config = 'pg_catalog.english'
      huge_pages = off
      EOF
      chown postgres:postgres /etc/postgresql/{{ postgres_version }}/main/postgresql.conf
  args:
    creates: /etc/postgresql/{{ postgres_version }}/main/postgresql.conf
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

# Enforce huge_pages = off (common fix for LXC)
- name: Enforce huge_pages = off in postgresql.conf
  ansible.builtin.lineinfile:
    path: /etc/postgresql/{{ postgres_version }}/main/postgresql.conf
    regexp: '^huge_pages\s*='
    line: "huge_pages = off"
    create: false
  when: postgresql_cluster_exists or postgresql_data_exists.stat.exists | default(false)
  notify: restart postgresql
  tags: ["config"]

# Create pg_hba.conf
- name: Generate pg_hba.conf for existing data
  ansible.builtin.copy:
    dest: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
    owner: postgres
    group: postgres
    mode: "0640"
    content: |
      # PostgreSQL Client Authentication Configuration File
      local   all             postgres                                peer
      local   all             all                                     peer
      host    all             all             127.0.0.1/32            scram-sha-256
      host    all             all             ::1/128                 scram-sha-256
      local   replication     all                                     peer
      host    replication     all             127.0.0.1/32            scram-sha-256
      host    replication     all             ::1/128                 scram-sha-256
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

# Create pg_ident.conf
- name: Generate pg_ident.conf for existing data
  ansible.builtin.copy:
    dest: /etc/postgresql/{{ postgres_version }}/main/pg_ident.conf
    owner: postgres
    group: postgres
    mode: "0640"
    content: |
      # PostgreSQL User Name Maps
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

# Now start cluster directly (skip pg_createcluster which has issues)
- name: Start existing cluster directly with pg_ctlcluster
  ansible.builtin.command:
    cmd: pg_ctlcluster {{ postgres_version }} main start
  register: postgresql_cluster_registered
  changed_when: "'server is running' not in postgresql_cluster_registered.stderr and 'server is running' not in postgresql_cluster_registered.stdout"
  failed_when:
    - postgresql_cluster_registered.rc != 0
    - "'server is running' not in postgresql_cluster_registered.stderr"
    - "'server is running' not in postgresql_cluster_registered.stdout"
  when:
    - not postgresql_cluster_exists
    - postgresql_data_exists.stat.exists | default(false)
  tags: ["install"]

- name: Display cluster start result
  ansible.builtin.debug:
    var: postgresql_cluster_registered
  when: postgresql_cluster_registered is defined
  tags: ["install"]

# Only create fresh cluster if NO existing data
- name: Create fresh PostgreSQL cluster (no existing data)
  ansible.builtin.command:
    cmd: pg_createcluster --datadir=/var/lib/postgresql/{{ postgres_version }}/main {{ postgres_version }} main
  when:
    - not postgresql_cluster_exists
    - not (postgresql_data_exists.stat.exists | default(false))
  register: postgresql_cluster_created
  tags: ["install"]

- name: Start newly created cluster
  ansible.builtin.command:
    cmd: pg_ctlcluster {{ postgres_version }} main start
  when: postgresql_cluster_created is changed
  tags: ["install"]

# --- Service Management ---

- name: Start and enable PostgreSQL service
  ansible.builtin.systemd:
    name: postgresql
    state: started
    enabled: true
  tags: ["service"]

- name: Restart PostgreSQL if cluster was just created or registered
  ansible.builtin.systemd:
    name: postgresql
    state: restarted
  when: postgresql_cluster_created is changed or (postgresql_cluster_registered is defined and postgresql_cluster_registered is changed)
  tags: ["service"]

# --- Ensure cluster is running ---

- name: Check cluster status
  ansible.builtin.command:
    cmd: pg_lsclusters
  register: postgresql_cluster_status
  changed_when: false
  tags: ["service"]

- name: Display cluster status
  ansible.builtin.debug:
    var: postgresql_cluster_status.stdout_lines
  tags: ["service"]

- name: Start cluster if down
  ansible.builtin.command:
    cmd: pg_ctlcluster {{ postgres_version }} main start
  register: postgresql_start_cluster
  when: "'down' in postgresql_cluster_status.stdout"
  changed_when: true
  ignore_errors: true
  tags: ["service"]

- name: Check PostgreSQL logs if start failed
  ansible.builtin.command:
    cmd: tail -n 50 /var/log/postgresql/postgresql-{{ postgres_version }}-main.log
  register: postgresql_logs
  changed_when: false
  when: postgresql_start_cluster is defined and (postgresql_start_cluster.failed | default(false))
  ignore_errors: true
  tags: ["service"]

- name: Display PostgreSQL logs on failure
  ansible.builtin.debug:
    var: postgresql_logs.stdout_lines
  when: postgresql_logs is defined and postgresql_logs.stdout_lines is defined
  tags: ["service"]

- name: Fail if cluster is down
  ansible.builtin.fail:
    msg: "PostgreSQL cluster failed to start. See logs above."
  when: postgresql_start_cluster is defined and (postgresql_start_cluster.failed | default(false))
  tags: ["service"]

- name: Wait for PostgreSQL to be ready
  ansible.builtin.wait_for:
    port: 5432
    host: 127.0.0.1
    delay: 3
    timeout: 30
  tags: ["service"]

# --- Vault Credentials ---

- name: Check for existing credentials in Vault
  ansible.builtin.uri:
    url: "{{ vault_addr }}/v1/{{ vault_kv_path }}"
    method: GET
    headers:
      X-Vault-Token: "{{ vault_token | default(lookup('env', 'VAULT_TOKEN')) }}"
    return_content: true
    status_code: [200, 404]
    validate_certs: false
  register: postgresql_vault_check
  tags: ["vault"]

- name: Use existing password from Vault
  ansible.builtin.set_fact:
    postgresql_db_password: "{{ postgresql_vault_check.json.data.data.db_password }}"
  no_log: true
  when:
    - postgresql_vault_check.status == 200
    - postgresql_vault_check.json.data.data.db_password is defined
  tags: ["vault"]

- name: Generate new password if not in Vault
  ansible.builtin.set_fact:
    postgresql_db_password: "{{ lookup('password', '/dev/null chars=ascii_letters,digits length=32') }}"
  no_log: true
  when: postgresql_db_password is not defined
  tags: ["vault"]

- name: Store credentials in Vault (if new or missing)
  ansible.builtin.uri:
    url: "{{ vault_addr }}/v1/{{ vault_kv_path }}"
    method: POST
    headers:
      X-Vault-Token: "{{ vault_token | default(lookup('env', 'VAULT_TOKEN')) }}"
    body_format: json
    body:
      data:
        db_password: "{{ postgresql_db_password }}"
        db_user: "{{ netbox_db_user }}"
        db_name: "{{ netbox_db_name }}"
        db_host: localhost
        db_port: 5432
    status_code: [200, 204]
    validate_certs: false
  no_log: true
  when: postgresql_vault_check.status == 404 or postgresql_vault_check.json.data.data.db_password is not defined
  tags: ["vault"]

# --- Database Setup ---

- name: Create database user
  community.postgresql.postgresql_user:
    name: "{{ netbox_db_user }}"
    password: "{{ postgresql_db_password }}"
    state: present
    encrypted: true
  become: true
  become_user: postgres
  no_log: true
  tags: ["database"]

- name: Check if database exists (bind mount may have existing data)
  community.postgresql.postgresql_query:
    db: postgres
    query: "SELECT 1 FROM pg_database WHERE datname='{{ netbox_db_name }}'"
  become: true
  become_user: postgres
  register: postgresql_db_exists
  tags: ["database"]

- name: Create database (only if not exists)
  community.postgresql.postgresql_db:
    name: "{{ netbox_db_name }}"
    owner: "{{ netbox_db_user }}"
    encoding: UTF8
    lc_collate: C.UTF-8
    lc_ctype: C.UTF-8
    template: template0
    state: present
  become: true
  become_user: postgres
  when: postgresql_db_exists.rowcount == 0
  tags: ["database"]

- name: Grant privileges to user
  community.postgresql.postgresql_privs:
    database: "{{ netbox_db_name }}"
    state: present
    privs: ALL
    type: database
    role: "{{ netbox_db_user }}"
  become: true
  become_user: postgres
  tags: ["database"]

# --- Configuration ---

- name: Configure pg_hba.conf for local connections
  ansible.builtin.lineinfile:
    path: /etc/postgresql/{{ postgres_version }}/main/pg_hba.conf
    regexp: '^local\s+all\s+{{ netbox_db_user }}'
    line: "local {{ netbox_db_name }} {{ netbox_db_user }} md5"
    insertafter: "^# TYPE"
  notify: restart postgresql
  tags: ["config"]

- name: Reload PostgreSQL configuration
  ansible.builtin.systemd:
    name: postgresql
    state: reloaded
  tags: ["config"]
